The adjacent vertices have index 1,3,5 therefore i output index 0,2,4

outputPixel = ( SourceColor*SourceBlendFactor ) BlendOp ( DestColor*DestinationBlendFactor )

SourceColor is a pixel being rendered when we draw the quad.
DestColor is the pixel that already exists in the framebuffer (from drawing the person)
BlendOp is the BlendOp from the SrcAlphaBlendingAdd blend structure
SourceBlendFactor is SrcBlend in the SrcAlphaBlendingAdd blend structure
DestinationBlendFactor is DestBlend in the SrcAlphaBlendingAdd blend structure


DrawThePixel? = DepthOfCurrentPixel D3D10_COMPARISON_LESS CurrentDepthInDepthBuffer
Draw the current pixel only if it's depth is LESS than the depth already stored at this location


use panda exporter for .x files


geometry shaders
with adj info 0,2,4
without 0,1,2


/*
[maxvertexcount(12)]
void GS( triangleadj GSPS_INPUT input[6], inout TriangleStream<GSPS_INPUT> TriStream )
{    
	        
    
    GSPS_INPUT output;    
    
  
    
    
    TriStream.Append( input[0] );
    TriStream.Append( input[2] );
    TriStream.Append( input[4] );
    TriStream.RestartStrip();

}
		//SetGeometryShader( CompileShader( gs_4_0, GS() ) );
*/



/*
        private static void DrawPointLights(GraphicsDeviceManager gdm)
        {
            pointLightInstances.Clear();
            foreach (Cell c in GameWorld.Cells)
            {
                foreach (Light l in c.Lights)
                {
                    if(l.lightType == LightType.Point)
                        pointLightInstances.Add(new Vector4(l.Position, l.Radius));
                }
            }

            DataStream ds = instanceData.Map(MapMode.WriteDiscard, SlimDX.Direct3D10.MapFlags.None);
            ds.Position = 0;
            ds.WriteRange(pointLightInstances.ToArray());
            instanceData.Unmap();

            EffectManager.UpdateCommonEffectVars(pointLightEffect, Matrix.Identity);            
            Game.Device.InputAssembler.SetPrimitiveTopology(PrimitiveTopology.TriangleListWithAdjacency);
            Game.Device.InputAssembler.SetIndexBuffer(pointLightIndexBuffer, Format.R16_UInt, 0);
            Game.Device.InputAssembler.SetVertexBuffers(0, pointLightpVB);
            Game.Device.InputAssembler.SetInputLayout(pointLightLayout);
            pointLightColorMapVar.SetResource(baseRT.srv);
            pointLightNormalMapVar.SetResource(normalRT.srv);
            pointLightDepthMapVar.SetResource(gdm.Direct3D10.DepthStencilSRV);
            pointLightInvMvp.SetMatrix(Matrix.Invert(Matrix.Translation(Camera.Position) * Camera.ViewMatrix * Camera.ProjectionMatrix) * Matrix.Translation(-1.0f, 1.0f, 0.0f) * Matrix.Scaling(2.0f, -2.0f, 1.0f));            
                        

            pointLightPass.Apply();
            Game.Device.DrawIndexedInstanced((pointLight.attrTable[0].FaceCount * 3) * 2, pointLightInstances.Count, 0, 0, 0);

            pointLightDepthMapVar.SetResource(null);
            pointLightColorMapVar.SetResource(null);
            pointLightNormalMapVar.SetResource(null);
            pointLightPass.Apply();            
        }
        */
        
        
        
        DepthStencilState Stencil
{
    DepthEnable = true;
    DepthWriteMask = ZERO;
    DepthFunc = LESS;

	StencilEnable = TRUE;	

	FrontFaceStencilFunc = Always;
	FrontFaceStencilDepthFail = REPLACE;
	FrontFaceStencilFail = Keep;
	FrontFaceStencilPass = Keep;

	BackFaceStencilFunc = Always;
	BackFaceStencilDepthFail = REPLACE;	
	BackFaceStencilFail = Keep;		
	BackFaceStencilPass = Keep;			
};
DepthStencilState Stencil2
{
    DepthEnable = true;
    DepthWriteMask = ZERO;
    DepthFunc = Always;
	
	StencilEnable = TRUE;

	FrontFaceStencilFail = Keep;	
	FrontFaceStencilDepthFail = Keep;
	FrontFaceStencilPass = Keep;
	FrontFaceStencilFunc = Equal;

	BackFaceStencilFail = Keep;	
	BackFaceStencilDepthFail = Keep;	
	BackFaceStencilPass = Keep;
	BackFaceStencilFunc = Equal;
};




private static void DrawBoxLights(GraphicsDeviceManager gdm)
        {
            Game.Device.InputAssembler.SetPrimitiveTopology(PrimitiveTopology.TriangleList);
            //Game.Device.InputAssembler.SetIndexBuffer(boxLight_IndexBuffer, Format.R16_UInt, 0);
            //Game.Device.InputAssembler.SetVertexBuffers(0, new VertexBufferBinding(boxLight_VertextBuffer, 16, 0));
            Game.Device.InputAssembler.SetInputLayout(ambientLightLayout);//boxLight_Layout);
            boxLight_ColorMapVar.SetResource(baseRT.srv);
            boxLight_NormalMapVar.SetResource(normalRT.srv);
            boxLight_PositionMapVar.SetResource(positionRT.srv);

            foreach (Light l in GameWorld.Cells[0].Lights)
            {
                if (l is BoxLight == false) continue;
                BoxLight pl = l as BoxLight;

                boxLight_ViewSpaceLightPosition.Set(Vector3.TransformCoordinate(pl.Position, Camera.ViewMatrix));
                boxLight_WorldViewProjection.SetMatrix(pl.GetLightVolumeWVP());
                boxLight_LightColor.Set(pl.Color * pl.Intensity);                


                Vector3 p = pl.Position;                
                Vector3 b1 = new Vector3(p.X + (pl.Width / 2), p.Y + (pl.Height / 2), p.Z + (pl.Depth / 2));
                Vector3 b2 = new Vector3(p.X - (pl.Width / 2), p.Y - (pl.Height / 2), p.Z - (pl.Depth / 2));
                EffectManager.GetEffectVar(boxLight_Effect, "b1").AsVector().Set(Vector3.TransformCoordinate(b1, Matrix.Translation(pl.Position) * Camera.ViewMatrix));
                EffectManager.GetEffectVar(boxLight_Effect, "b2").AsVector().Set(Vector3.TransformCoordinate(b2, Matrix.Translation(pl.Position) * Camera.ViewMatrix));
                //EffectManager.GetEffectVar(boxLight_Effect, "b1").AsVector().Set(b1);
                //EffectManager.GetEffectVar(boxLight_Effect, "b2").AsVector().Set(b2);

                Vector3 top = new Vector3(p.X, p.Y + (pl.Height / 2), p.Z);
                Vector3 bottom = new Vector3(p.X, p.Y - (pl.Height / 2), p.Z);
                Vector3 worldSpaceLightDirection = Vector3.Normalize(bottom - top);
                Vector3 viewSpaceLightDirection;
                viewSpaceLightDirection = Vector3.TransformNormal(worldSpaceLightDirection, Camera.ViewMatrix);
                EffectManager.GetEffectVar(boxLight_Effect, "g_fvViewSpaceLightDirection").AsVector().Set(worldSpaceLightDirection);//viewSpaceLightDirection);
                
                EffectManager.GetEffectVar(boxLight_Effect, "matView").AsMatrix().SetMatrix(Camera.ViewMatrix);
                
                EffectManager.GetEffectVar(boxLight_Effect, "matWorldView2").AsMatrix().SetMatrix(Matrix.Translation(pl.Position) * Camera.ViewMatrix);
                EffectManager.GetEffectVar(boxLight_Effect, "matWorld2").AsMatrix().SetMatrix(Matrix.Translation(pl.Position));


                EffectManager.GetEffectVar(boxLight_Effect, "matViewInverse").AsMatrix().SetMatrix(Matrix.Invert(Camera.ViewMatrix));

                boxLight_Tech.GetPassByIndex(0).Apply();
                //Game.Device.DrawIndexed((boxLight.attrTable[0].FaceCount * 3) * 2, 0, 0);
                Game.Device.Draw(3, 0);   
            }

            UnbindMRT(boxLight_Tech, boxLight_ColorMapVar, boxLight_NormalMapVar, boxLight_PositionMapVar);
        }
















		    public interface ILightBehavior
    {
        void Update(Light l);
    }

    public class BlinkingLightBehavior : ILightBehavior
    {
        private float time = 0;
        public float BlinkInterval = 3.0f;

        public void Update(Light l)
        {
            time += Game.Time.ElapsedGameTime;
            if (time > BlinkInterval)
            {
                l.toggle();
                time = 0.0f;
            }
        }
    }
    public class BrokenLightBehavior : ILightBehavior
    {
        private bool gotRandomNum = false;
        private int randomNum = 0;
        private float time = 0;

        public void Update(Light l)
        {
            time += Game.Time.ElapsedGameTime;

            if (!gotRandomNum)
            {
                Random r = new Random();
                randomNum = r.Next(1, 2);
                gotRandomNum = true;
            }
            if (time > randomNum)
            {
                l.toggle();
                time = 0.0f;
                gotRandomNum = false;
            }
        }
    }
    public class PulsingLightBehavior : ILightBehavior
    {
        public float ExpandAmount = 0.1f;
        public float MinRadius = 5.0f;

        private bool setRadius = false;
        private bool dir = false;
        private float initialRadius = 300;

        public void Update(Light l)
        {
            if (!setRadius)
            {
                initialRadius = l.MaxRange;
                setRadius = true;
            }
            if (dir)
                l.MaxRange += ExpandAmount;
            else
                l.MaxRange -= ExpandAmount;

            if (l.MaxRange <= MinRadius || l.MaxRange == initialRadius) //toggle dir
                dir = !dir;
        }
    }
    public class PoliceLightBehavior : ILightBehavior
    {
        private bool reachedBlue = false;
        private bool reachedRed = false;
        private bool firstUpdate = true;

        public void Update(Light l)
        {
            if (firstUpdate)
            {
                reachedBlue = true;
                l.Color = new SlimDX.Vector3(0, 0, 1);
                firstUpdate = false;
            }
            SlimDX.Vector3 lc = l.Color;

            if (reachedBlue == false)
            { //lerp to blue
                lc.X -= 0.1f;
                lc.Z += 0.1f;
                if (lc.Z >= 1.0f)
                {
                    reachedBlue = true;
                    reachedRed = false;
                }
            }
            if (reachedRed == false)
            { //lerp to red
                lc.X += 0.1f;
                lc.Z -= 0.1f;
                if (lc.X >= 1.0f)
                {
                    reachedBlue = false;
                    reachedRed = true;
                }
            }

            l.Color = lc;           
        }
    }   





































	#include "common.inc" 

Texture3D SplashBumpTexture;
Texture3D SplashDiffuseTexture;
float g_timeCycle;
float g_splashXDisplace;
float g_splashYDisplace;
float4x4 matSplashScale;
float4x4 matSplashViewInv;
SamplerState samAnisoMirror
{
  Filter = ANISOTROPIC;
  AddressU = Mirror;
  AddressV = Mirror;
};

Texture2D Base;
SamplerState BaseSampler
{
    Filter = ANISOTROPIC;
    AddressU = Wrap;
    AddressV = Wrap;
};
Texture2D NormalMap;
bool useFaceNormals;



struct VsIn
{
	float4 position : POSITION;	
	float3 normal : NORMAL;
	float2 texCoord: TEXCOORD0;		
	float3 tangent : TANGENT;
    float3 binormal : BINORMAL;
};

struct PsIn
{
	float4 position : SV_Position;	
    float4 PosView	: TEXCOORD0;
    float2 texCoord	: TEXCOORD1;    		
	float3 faceNormal : TEXCOORD2;	
	float4 worldPos : WPOSITION;
	float3x3 TangentToView : TEXCOORD3;			
};

PsIn VS( VsIn input )
{
	PsIn output = (PsIn)0;
	
	output.position = mul( input.position, WorldViewProj );				
	output.PosView = mul(input.position, WorldView);	
	output.texCoord = input.texCoord;		
	
	float3x3 matTBN = float3x3( input.tangent, input.binormal, input.normal );	
	output.TangentToView = mul( matTBN, (float3x3)WorldView );
	output.faceNormal = mul( input.normal, (float3x3)WorldView );
	

	output.worldPos = mul( input.position, matSplashScale ); 
	
	return output;
}


struct PsOut {
	float4 base   : SV_Target0;
	float4 normal : SV_Target1;
	float4 pos : SV_Target2;	
};
PsOut PS( PsIn In )
{
	PsOut Out;	
	Out.base = Base.Sample(BaseSampler, In.texCoord);	
	Out.pos = float4( In.PosView.xyz, 1.0f );	 

	if(useFaceNormals){
		Out.normal = float4(In.faceNormal, 1);
	} else {
		float3 bump = NormalMap.Sample(BaseSampler, In.texCoord).xyz * 2.0f - 1.0f;				
		float3 viewSpaceNormal = normalize( mul( bump, In.TangentToView ) );		
		Out.normal = float4(viewSpaceNormal,1);		
	}
	
	
	return Out;
}

technique10 RenderBuffers
{
	pass P0
	{
		SetGeometryShader( 0 );
		SetVertexShader( CompileShader( vs_4_0, VS() ) );
		SetPixelShader( CompileShader( ps_4_0, PS() ) );		
		
		
		SetRasterizerState( RS_NormalSolid );		
		SetDepthStencilState( DS_EnableDepth, 0 );
        SetBlendState( BS_NoBlending, float4( 0.0f, 0.0f, 0.0f, 0.0f ), 0xFFFFFFFF );		
	}	
}














BEPU
//[StructLayout(LayoutKind.Explicit)]
        //internal struct EntityStateChange
        //{
        //    [FieldOffset(0)]
        //    internal Quaternion orientationQuaternion;
        //    [FieldOffset(0)]
        //    internal Vector3 vector;
        //    [FieldOffset(16)]
        //    internal TargetField targetField;
        //    [FieldOffset(20)]
        //    internal Entity target;
        //}

        [StructLayout(LayoutKind.Auto)]
        internal struct EntityStateChange
        {
            
            internal Quaternion orientationQuaternion;
            
            internal Vector3 vector;
            
            internal TargetField targetField;
            
            internal Entity target;
        }